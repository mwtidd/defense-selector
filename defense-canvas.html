<!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->
<link rel="import" href="../polymer/polymer.html">

<link rel="import" href="../font-roboto-local/roboto.html">

<link rel="import" href="../paper-dialog/paper-dialog.html">
<link rel="import" href="../paper-progress/paper-progress.html">

<link rel="import" href="../platinum-sw/platinum-sw-register.html">
<link rel="import" href="../platinum-sw/platinum-sw-cache.html">

<script src="../interact/dist/interact.min.js"></script>

<!--
An element to start from.

Example:

    <defense-selector></defense-selector>

@demo
-->
<dom-module id="defense-canvas">

  <style is="custom-style">
    :host {
      display: block;
      font-family: 'Roboto';
      background-color: rgb(54,54,54);
      overflow: hidden;
      position: relative;
    }

    :host #viewport{
      float:left;
      width: 100%;
      height: 100%;
    }

    :host #view{
      position: relative;
    }

    :host canvas{
      position: absolute;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
    }

    :host #targets{
      display: none;
    }

    :host #targets.A0, :host #targets.A180{
      display: block;
      position: absolute;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
    }



    :host #targets > div{
      position: absolute;
      top: 0;
      left: 0;
      width: 8%;
      height: 7%;
      cursor: pointer;
    }

    :host #targets > div:after {
      position: absolute;
      bottom: 0;
      left: 10%;
      width: 80%;
      content: "";
      height: 3px;
      background: rgba(255,255,255,.3);
      transition: all 250ms linear;

      display: block;
    }

    :host #targets > div.selected:after{
      left: 0;
      width: 100%;
      background: rgba(255,255,255,1);
    }

    :host #targets.A0 .r{
      top: 35%;
    }

    :host #targets.A0 #r2 {
       left: 34.5%;
     }

    :host #targets.A0 #r3 {
      left: 42%;
    }

    :host #targets.A0 #r4 {
      left: 51%;
    }

    :host #targets.A0 #r5 {
      left: 58%;
    }

    :host #targets.A0 .b{
      top: 59%;
    }

    :host #targets.A0 #b5 {
      left: 33%;
    }

    :host #targets.A0 #b4 {
      left: 42%;
    }

    :host #targets.A0 #b3 {
      left: 50%;
    }

    :host #targets.A0 #b2 {
      left: 60%;
    }



    :host #targets #r1{
      display: none;
    }

    :host #targets #b1{
      display: none;
    }


    :host #targets.A180 .b{
      top: 35%;
    }

    :host #targets.A180 #b2 {
      left: 34.5%;
    }

    :host #targets.A180 #b3 {
      left: 45%;
    }

    :host #targets.A180 #b4 {
      left: 50%;
    }

    :host #targets.A180 #b5 {
      left: 58%;
    }

    :host #targets.A180 .r{
      top: 60%;
    }

    :host #targets.A180 #r5 {
      left: 33%;
    }

    :host #targets.A180 #r4 {
       left: 42%;
     }

    :host #targets.A180 #r3 {
      left: 51%;
    }

    :host #targets.A180 #r2 {
      left: 60%;
    }

  </style>

  <template>
    <content></content>
    <div id="viewport">
      <div id="view">
        <canvas id="canvas"></canvas>
        <div id="targets" class$="{{side}}">
          <template is="dom-repeat" items="{{models}}" as="model">
            <div id$="[[model.id]]" class$="dropzone [[model.color]] [[getSelectedCss(model.selected)]]" on-tap="onSelectModel"></div>
          </template>
        </div>
      </div>
    </div>


    <paper-dialog opened="[[!loaded]]">
      <h2>Installing the Defense Selector</h2>
      <div>[[loadingState]]</div>
      <paper-progress indeterminate="[[indeterminateLoadingState]]"></paper-progress>
    </paper-dialog>

    <platinum-sw-register id="imageService" state="{{imageServiceState}}">

      <platinum-sw-cache id="imageCache" precache="[[precacheUrls]]"></platinum-sw-cache>

    </platinum-sw-register>


  </template>

</dom-module>

<script>

  Polymer({

    is: 'defense-canvas',

    behaviors: [

    ],

    listeners: {
      'service-worker-installed': 'onInstalled',
      'service-worker-updated': 'onUpdated',
      'service-worker-error': 'onError',
      'view.track' : 'onDrag',
    },

    properties: {

      initialized: {
        type: Boolean,
        value: false
      },

      autoScaled: {
        type: Boolean,
        value: false
      },

      side:{
        type: String,
        value: "A0",
        observer: 'onSideChange'
      },

      color: {
        type: String,
        value: ""
      },

      installed: {
        type: Boolean,
        value: false
      },


      indeterminateLoadingState: {
        type: Boolean,
        value: true
      },

      loadingState: {
        type: String,
        value: "initializing..."
      },

      loaded: {
        type: Boolean,
        value: false,
        observer: 'onLoadedChange'
      },

      audienceRedCategory: {
        type: String,
        value: "a"
      },

      audienceBlueCategory: {
        type: String,
        value: "b"
      },


      imageServiceState: {
        type: Object,
        value: function(){
          return {} ;
        },
        observer: 'onImageServiceStateChange'
      },

        backgroundImage: {
          type: String,
          value: null
        },

        scalar: {
          type: Number,
          value: 4
        },

        precacheUrls: {
          type: Array,
          value: function(){
            return [];
          },
        },

      imageUrl: {
        type: "String",
        value: ""
      },

      models: {
        type: Object,
        value: function(){
          return null;
        }
      },

      staticModels: {
        type: Object,
        value: function(){
          return null;
        }
      },

      selectionModels: {
        type: Object,
        value: function(){
          return null;
        }
      },

      imageMap: {
        type: Object,
        value: function(){
          return null;
        }
      },

      currentStep: {
        type: Number,
        value: 0
      }



    },

    // Element Lifecycle

    ready: function() {
      // `ready` is called after all elements have been configured, but
      // propagates bottom-up. This element's children are ready, but parents
      // are not.
      //
      // This is the point where you should make modifications to the DOM (when
      // necessary), or kick off any processes the element wants to perform.

      if(this.installed){
        this.set("loading", false);
      }
    },

    attached: function() {
      // `attached` fires once the element and its parents have been inserted
      // into a document.
      //
      // This is a good place to perform any work related to your element's
      // visual state or active behavior (measuring sizes, beginning animations,
      // loading resources, etc).

    },

    detached: function() {
      // The analog to `attached`, `detached` fires when the element has been
      // removed from a document.
      //
      // Use this to clean up anything you did in `attached`.
    },

    // Element Behavior

    initPrecache: function(){
        if(!this.installed){
          this.set("loadingState", "indexing images...");


          for (var property in this.imageMap) {
            this.push("precacheUrls", this.imageUrl+"/layers/items/" + property + ".png");
          }

        this.set("loadingState", "downloading images...");

        this.$.imageService.register();
      }else{
        this.set("loaded", true);
      }
    },

    getSelectedCss: function(isSelected){
      if(isSelected){
        return "selected";
      }

      return "";
    },

    onSideChange: function(event){
      this.paintScene();
    },

    onInstalled: function(event){
      console.log("sw installed");
      this.set("loaded", true);
    },

    onUpdated: function(event){
      console.log("sw updated");
      this.set("loaded", true);
    },

    onError: function(event){
      console.error("A service worker error occurred");
    },

    onImageServiceStateChange: function(state){
      if(!this.installed){
        if(state == "installed" || state == "updated"){
          console.log("sw is good");
          this.set("loaded", true);
        }else if(state == "unsupported"){
          alert("We're sorry, but your browser doesn't support service workers. Please try the latest version of Chrome.");
        }else{
          console.log("unknown sw state");
        }
      }
    },

    onLoadedChange: function(loaded){
      if(loaded === true){
        this.paintScene();
      }
    },

    onSelectModel: function(event){
      var model = event.model.model;
      //model.set("item.selected", true);

      for(var i = 0; i < this.models.length; i++){
        var _model = this.models[i];
        if(_model.id == model.id){
          this.set("models." + i + ".selected", true);
        }else{
          this.set("models." + i + ".selected", false);
        }
      }

      this.fire("model-selected", model);
    },

    onDrag: function(event){
      if(event.detail.state == "start"){
        this.startDrag(event);
      }else if(event.detail.state == "end"){
        this.endDrag();
      }else if(event.detail.state == "track"){
        this.debounce("drag", this.drag(event),250);
      }
    },

    startDrag: function(event){
      //this.sceneWidth = $(".scene").outerWidth();
      //this.vignetteWidth = $(".scene .image").outerWidth();

      this.dragging = true;

      this.startX = event.detail.x;//0;
      this.startY = event.detail.y;//0;

      this.startLeft = this.$.view.style.marginLeft.replace("px", "");
      this.startTop = this.$.view.style.marginTop.replace("px", "");

      /**
       this.startX = Math.ceil(event.pageX);
       this.startY = Math.ceil(event.pageY);

       if(!this.startX && !this.startY){
        this.startX = event.originalEvent.touches[0].pageX;
        this.startY = event.originalEvent.touches[0].pageY;
      }
       **/

      //this.startLeft = $(".scene > .image").css("margin-left").replace("px", "");
      //this.startTop = $(".scene > .image").css("margin-top").replace("px", "");
      //this.dragging = true;
    },


    drag: function(event){
      if(!this.dragging){
        this.startDrag(event);
      }

      var newX = event.detail.x;//0;
      var newY = event.detail.y;//0;

      /**
       newX = event.pageX;
       newY = event.pageY;

       if(!newX && !newY){
          newX = event.originalEvent.touches[0].pageX;
          newY = event.originalEvent.touches[0].pageY;
        }
       **/

      var deltaX = this.startX - newX;
      var deltaY = this.startY - newY;

      var newLeft = Math.ceil(this.startLeft - deltaX);
      var newTop = Math.ceil(this.startTop - deltaY);


      var vignetteWidth = this.$.view.offsetWidth;
      var sceneWidth = this.$.viewport.offsetWidth;

      if(sceneWidth < vignetteWidth){
        var maxX = vignetteWidth - sceneWidth;
        var minX = 0;

        if(-1 * newLeft > maxX){
          newLeft = -1*maxX;
        }else if(-1 * newLeft < minX){
          newLeft = -1 * minX;
        }

        this.$.view.style.marginLeft = newLeft + "px";
      }



      var vignetteHeight = this.$.view.offsetHeight;
      var sceneHeight = this.$.viewport.offsetHeight;

      if(sceneHeight < vignetteHeight){
        var maxY = vignetteHeight - sceneHeight;
        var minY = 0;

        if(-1 * newTop > maxY){
          newTop = -1*maxY;
        }else if(-1 * newTop < minY){
          newTop = -1 * minY;
        }

        this.$.view.style.marginTop = newTop + "px";
      }







      //$(".scene > .image").css("margin-left",newLeft + "px");
      //$(".scene > .image").css("margin-top",newTop + "px");

    },

    endDrag: function(){
      // if(!this.dragging) return;
      this.dragging = false;
    },

    allianceFilter: function(color){
      if (!color) {
        //do not allow selecting until an alliance has been selected
        return true;
      } else {
        // return a filter function for the current search string
        return function(model) {
          if(model.color == color){
            return true;
          }
          return false;
        };
      }
    },

    autoScale: function(){
      var sceneWidth = this.$.viewport.offsetWidth;
      var targetWidth = 1.146 * sceneWidth;
      this.set("scalar", 2048 / targetWidth);

      this.autoScaled = true;

      this.paintScene();
    },

    initialize: function(){

      var vignetteWidth = this.$.view.offsetWidth;
      var sceneWidth = this.$.viewport.offsetWidth;
      var vignetteHeight = this.$.view.offsetHeight;
      var sceneHeight = this.$.viewport.offsetHeight;

      //move to bottom
      if(sceneHeight < vignetteHeight){
        var maxY = vignetteHeight - sceneHeight;

        this.$.view.style.marginTop = (-1 * maxY + 16) + "px";


      }

      //center
      if(sceneWidth < vignetteWidth){
        var maxX = vignetteWidth - sceneWidth;
        this.$.view.style.marginLeft = -1 * (maxX / 2) + "px";
      }

      this.initialized = true;
      this.fire("initialized");
      this.paintScene();
    },

    paintScene: function(){
      var context = this.$.canvas.getContext("2d");

      this.set("loadingState", "loading field...");

      var _bg = new Image();
      _bg.src = this.imageUrl+ "/layers/items/" + this.backgroundImage;
      _bg.onload = function() {

        context.canvas.height = _bg.height / this.scalar;
        context.canvas.width = _bg.width / this.scalar;
        /**

        this.$.targets.style.height = (_bg.height / this.scalar) + "px";
        this.$.targets.style.width = (_bg.width / this.scalar) + "px";
         **/

        this.$.view.style.height = (_bg.height / this.scalar) + "px";
        this.$.view.style.width = (_bg.width / this.scalar) + "px";

        if(!this.autoScaled){
          this.autoScale();
          return;
        }

        if(!this.initialized){
          this.initialize();
          return;
        }

        context.clearRect(0, 0, context.canvas.width, context.canvas.height);
        context.drawImage(_bg, 0, 0, _bg.width, _bg.height, 0, 0, _bg.width / this.scalar, _bg.height / this.scalar);

        this.set("loadingState", "loading bases...");

        var count = this.staticModels.length;
        this.staticModels.forEach(function (model) {


          var fileName = "" +this.side+"_" + model.id+ "_base";
          var image = this.get("imageMap." + fileName);

          var _img = new Image();

          _img.src = this.imageUrl + "/layers/items/" + fileName + ".png";
          _img.onload = function () {
            count--;
            context.drawImage(_img, 0, 0, _img.width, _img.height, image.x / this.scalar, image.y / this.scalar, _img.width / this.scalar, _img.height / this.scalar);
            if(count == 0){
              this.loadDynamicImages();
            }
          }.bind(this);
        }.bind(this));

      }.bind(this);
    },

    loadDynamicImages: function(){
      var context = this.$.canvas.getContext("2d");

      this.set("loadingState", "loading defenses...");

      this.models.forEach(function(model){
        model.options.forEach(function(option){
          option.items.forEach(function(item){
            if(item.selected){

              var fileName = ""+this.side+"_" + model.color + "_" + model.sku + "_"+item.sku;

              var image = this.get("imageMap." + fileName);

              var _img = new Image();
                _img.src = this.imageUrl + "/layers/items/" + fileName + ".png";
                _img.onload = function(){
                  context.drawImage(_img, 0, 0, _img.width , _img.height , image.x / this.scalar, image.y / this.scalar, _img.width / this.scalar, _img.height / this.scalar);
                }.bind(this);
              }
          },this);
        },this);
      },this);

      this.setupDropZone();
    },

    setupDropZone:function(){
      //Get all dropzones
      var dropZones = Polymer.dom(this.root).querySelectorAll('.dropzone');
      var self = this;
      dropZones.forEach(function(dropzone){
        interact(dropzone).dropzone({

          accept:'.thumbnail',
          overlap:'pointer',
          ondragenter:function(ev){
            self.toggleClass('active', true, ev.target);
            //console.log('drag enter');

          },
          ondragleave:function(ev){
            self.toggleClass('active', false, ev.target);

          },
          ondrop:function(ev){
            var card = ev.relatedTarget;
            var dropzone = ev.target;
            var modelId = Polymer.dom(dropzone).node.id;
            var itemSku = Polymer.dom(card).node.sku;


            for(var i = 0; i < this.models.length; i++) {
              var model = this.models[i];
              if (model.id == modelId) {
                for (var x = 0; x < model.options.length; x++) {
                  var option = model.options[x];
                  for (var y = 0; y < option.items.length; y++) {
                    var item = option.items[y];
                    if (item.sku == itemSku) {
                      this.set("models." + i + ".options." + x + ".items." + y + ".selected", true);
                    } else {
                      this.set("models." + i + ".options." + x + ".items." + y + ".selected", false);
                    }
                  }
                }
              }
            }

            //Polymer.dom(card).node.set("hidden",true);
            this.paintScene();
          }.bind(this)

        }, this);
      }, this);

    }

  });

</script>
